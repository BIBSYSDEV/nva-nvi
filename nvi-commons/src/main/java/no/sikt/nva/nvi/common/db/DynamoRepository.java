package no.sikt.nva.nvi.common.db;

import static java.util.Objects.isNull;
import static no.sikt.nva.nvi.common.DatabaseConstants.HASH_KEY;
import static no.sikt.nva.nvi.common.DatabaseConstants.SORT_KEY;
import static no.sikt.nva.nvi.common.utils.ApplicationConstants.REGION;

import java.util.Map;
import java.util.concurrent.CompletableFuture;
import nva.commons.core.JacocoGenerated;
import software.amazon.awssdk.auth.credentials.DefaultCredentialsProvider;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbEnhancedClient;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbTable;
import software.amazon.awssdk.enhanced.dynamodb.Expression;
import software.amazon.awssdk.enhanced.dynamodb.Key;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AtomicCounterExtension;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedTimestampRecordExtension;
import software.amazon.awssdk.enhanced.dynamodb.extensions.VersionedRecordExtension;
import software.amazon.awssdk.enhanced.dynamodb.model.GetItemEnhancedRequest;
import software.amazon.awssdk.enhanced.dynamodb.model.TransactPutItemEnhancedRequest;
import software.amazon.awssdk.enhanced.dynamodb.model.TransactWriteItemsEnhancedRequest;
import software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient;
import software.amazon.awssdk.services.dynamodb.DynamoDbClient;
import software.amazon.awssdk.services.dynamodb.model.AttributeValue;
import software.amazon.awssdk.services.dynamodb.model.QueryRequest;
import software.amazon.awssdk.services.dynamodb.model.QueryResponse;

public class DynamoRepository {
  private static final String PARTITION_KEY_NAME_PLACEHOLDER = "#partitionKey";
  private static final String SORT_KEY_NAME_PLACEHOLDER = "#sortKey";
  protected final DynamoDbEnhancedClient client;
  protected final DynamoDbClient defaultClient;

  protected DynamoRepository(DynamoDbClient client) {
    this.defaultClient = client;
    this.client =
        DynamoDbEnhancedClient.builder()
            .dynamoDbClient(client)
            .extensions(
                AutoGeneratedTimestampRecordExtension.create(),
                AtomicCounterExtension.builder().build(),
                VersionedRecordExtension.builder().build())
            .build();
  }

  protected GetItemEnhancedRequest getByKey(Key key) {
    return GetItemEnhancedRequest.builder().key(key).consistentRead(true).build();
  }

  protected CompletableFuture<QueryResponse> executeAsync(QueryRequest query) {
    return CompletableFuture.supplyAsync(() -> defaultClient.query(query));
  }

  private static String keyNotExistsCondition() {
    return String.format(
        "attribute_not_exists(%s) AND attribute_not_exists(%s)",
        PARTITION_KEY_NAME_PLACEHOLDER, SORT_KEY_NAME_PLACEHOLDER);
  }

  private static Map<String, String> primaryKeyEqualityConditionAttributeNames() {
    return Map.of(
        PARTITION_KEY_NAME_PLACEHOLDER, HASH_KEY,
        SORT_KEY_NAME_PLACEHOLDER, SORT_KEY);
  }

  protected static Expression uniquePrimaryKeysExpression() {
    return Expression.builder()
        .expression(keyNotExistsCondition())
        .expressionNames(primaryKeyEqualityConditionAttributeNames())
        .build();
  }

  @JacocoGenerated
  public static DynamoDbClient defaultDynamoClient() {
    return DynamoDbClient.builder()
        .httpClient(UrlConnectionHttpClient.create())
        .credentialsProvider(DefaultCredentialsProvider.builder().build())
        .region(REGION)
        .build();
  }

  /**
   * Creates an expression that checks that the item revision matches the expected value. If
   * expectedRevision is null, checks that the revision attribute doesn't exist.
   */
  protected static Expression requireExpectedRevision(Long expectedRevision) {
    if (isNull(expectedRevision)) {
      return Expression.builder().expression("attribute_not_exists(revision)").build();
    }
    return Expression.builder()
        .expression("revision = :expectedRevision")
        .expressionValues(
            Map.of(
                ":expectedRevision",
                AttributeValue.builder().n(expectedRevision.toString()).build()))
        .build();
  }

  /** Creates a PUT request that requires the item to not already exist (unique insert). */
  private static <T> TransactPutItemEnhancedRequest<T> createNewItem(
      T item, DynamoDbTable<T> table) {
    return TransactPutItemEnhancedRequest.builder(table.tableSchema().itemType().rawClass())
        .item(item)
        .conditionExpression(uniquePrimaryKeysExpression())
        .build();
  }

  /**
   * Add a new item to the transaction, with both a mutated version field and a constraint that
   * requires the item to not already exist.
   */
  protected <T extends Dao> void addNewItemWithVersion(
      TransactWriteItemsEnhancedRequest.Builder transaction, DynamoDbTable<T> table, T item) {
    var putItem = createNewItem((T) item.withMutatedVersion(), table);
    transaction.addPutItem(table, putItem);
  }

  /** Add an updated item to the transaction with a mutated version field. */
  protected <T extends Dao> void addUpdatedItemWithVersion(
      TransactWriteItemsEnhancedRequest.Builder transaction, DynamoDbTable<T> table, T item) {
    transaction.addPutItem(table, (T) item.withMutatedVersion());
  }
}
