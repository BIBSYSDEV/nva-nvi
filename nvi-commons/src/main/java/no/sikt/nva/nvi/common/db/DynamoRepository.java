package no.sikt.nva.nvi.common.db;

import static java.util.Objects.isNull;
import static no.sikt.nva.nvi.common.DatabaseConstants.HASH_KEY;
import static no.sikt.nva.nvi.common.DatabaseConstants.SORT_KEY;
import static no.sikt.nva.nvi.common.utils.ApplicationConstants.NVI_TABLE_NAME;
import static no.sikt.nva.nvi.common.utils.ApplicationConstants.REGION;

import java.util.Map;
import java.util.concurrent.CompletableFuture;
import nva.commons.core.JacocoGenerated;
import software.amazon.awssdk.auth.credentials.DefaultCredentialsProvider;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbEnhancedClient;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbTable;
import software.amazon.awssdk.enhanced.dynamodb.Expression;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AtomicCounterExtension;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedTimestampRecordExtension;
import software.amazon.awssdk.enhanced.dynamodb.extensions.VersionedRecordExtension;
import software.amazon.awssdk.enhanced.dynamodb.model.TransactPutItemEnhancedRequest;
import software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient;
import software.amazon.awssdk.services.dynamodb.DynamoDbClient;
import software.amazon.awssdk.services.dynamodb.model.AttributeValue;
import software.amazon.awssdk.services.dynamodb.model.QueryRequest;
import software.amazon.awssdk.services.dynamodb.model.QueryResponse;

public class DynamoRepository {
  private static final String PARTITION_KEY_NAME_PLACEHOLDER = "#partitionKey";
  private static final String SORT_KEY_NAME_PLACEHOLDER = "#sortKey";
  protected final DynamoDbEnhancedClient client;
  protected final DynamoDbClient defaultClient;

  protected DynamoRepository(DynamoDbClient client) {
    this.defaultClient = client;
    this.client =
        DynamoDbEnhancedClient.builder()
            .dynamoDbClient(client)
            .extensions(
                AutoGeneratedTimestampRecordExtension.create(),
                AtomicCounterExtension.builder().build(),
                VersionedRecordExtension.builder().build())
            .build();
  }

  protected CompletableFuture<QueryResponse> executeAsync(QueryRequest query) {
    return CompletableFuture.supplyAsync(() -> defaultClient.query(query));
  }

  protected static QueryRequest queryByPartitionKey(String partitionKey) {
    return QueryRequest.builder()
        .tableName(NVI_TABLE_NAME)
        .keyConditionExpression("#pk = :pk")
        .expressionAttributeNames(Map.of("#pk", HASH_KEY))
        .expressionAttributeValues(Map.of(":pk", AttributeValue.builder().s(partitionKey).build()))
        .consistentRead(true)
        .build();
  }

  private static String keyNotExistsCondition() {
    return String.format(
        "attribute_not_exists(%s) AND attribute_not_exists(%s)",
        PARTITION_KEY_NAME_PLACEHOLDER, SORT_KEY_NAME_PLACEHOLDER);
  }

  private static Map<String, String> primaryKeyEqualityConditionAttributeNames() {
    return Map.of(
        PARTITION_KEY_NAME_PLACEHOLDER, HASH_KEY,
        SORT_KEY_NAME_PLACEHOLDER, SORT_KEY);
  }

  protected static Expression uniquePrimaryKeysExpression() {
    return Expression.builder()
        .expression(keyNotExistsCondition())
        .expressionNames(primaryKeyEqualityConditionAttributeNames())
        .build();
  }

  @JacocoGenerated
  public static DynamoDbClient defaultDynamoClient() {
    return DynamoDbClient.builder()
        .httpClient(UrlConnectionHttpClient.create())
        .credentialsProvider(DefaultCredentialsProvider.create())
        .region(REGION)
        .build();
  }

  /**
   * Creates an expression that checks that the item revision matches the expected value. If
   * expectedRevision is null, checks that the revision attribute doesn't exist.
   */
  protected static Expression requireExpectedRevision(Long expectedRevision) {
    if (isNull(expectedRevision)) {
      return Expression.builder().expression("attribute_not_exists(revision)").build();
    }
    return Expression.builder()
        .expression("revision = :expectedRevision")
        .expressionValues(
            Map.of(
                ":expectedRevision",
                AttributeValue.builder().n(expectedRevision.toString()).build()))
        .build();
  }

  /** Creates a PUT request that requires the item to not already exist (unique insert). */
  protected static <T> TransactPutItemEnhancedRequest<T> createNewItem(
      T item, DynamoDbTable<T> table) {
    return TransactPutItemEnhancedRequest.builder(table.tableSchema().itemType().rawClass())
        .item(item)
        .conditionExpression(uniquePrimaryKeysExpression())
        .build();
  }
}
